solver_blas.c
Am ales sa implementez cu functii cblas_dgemm. Folosind cblas.h.
Functia DGEMM executa operatia de tipul C=alpha*A*B+beta*C, unde A sau B poate fi declarata ca fiind transpusa.

 
Operatia C= B*At+A2*B este impartita in trei etape-trei functii cblas_dgemm:
Prima functie cblas_dgemm executa C=B*At
A doua functie cblas_dgemm : A2=A*A
Ultima functie cblas_dgemm: C=A2*B + C .

Aditional, A2 este o matrice de tipul A sau B, folosita pentru a salva operatia de A*A.
Timpul minim oferit pentru  N=1200: Time=1.217092.


solver_neopt.c
In implementarea operatiei C= B*At+A2*B s-a tinut cont de faptul ca matricea A
este o matrice triunghiular superioara, astfel incat am incercat sa reduc numarul operatiilor inutile
(cele compuse doar de elemente = 0).
Am folosit o matrice A2 pentru a retine operatia A*A si in acest caz am parcurs 
toata matricea A pentru a initializa fiecare element al matricei A2.
Pentru evitarea operatiilor inutile am pus conditii precum i>=j, i<j sau k pornind de la j, respectiv i.
Complexitatea fara aceste conditii ar fi de O(n^3).
Operatia finala s-a fact cu 3 seturi a cate 3 for-uri: unul pentru A2, urmatorul pentru B*At si ultimul
pentru A2*B.
Timpul minim oferit pentru  N=1200: Time=16.269058.


solver_opt.c
Pentru optimizare, am folosit registrii si pointeri.
Registrii-  Variabila sum este retinuta intr-un registru. 
Aceasta este utilizata la toate operatiile intre matrici pentru a evita accesul repetat al elementului calculat la final(A2[i][j] sau C[i][j]).
Pointeri- renuntarea la accesele vectoriale (matricile A, B, A2, C) prin derefentiere.
De asemenea, am pastrat conditiile pentru matricile triunghiular superioare sau inferioare, k ce porneste de la j sau i si 
am evitat sa mai accesez un element al unei matrici unde rezultatul nu era relevant pentru rezultatul final.
Cel mai mic timp obtinut pentru N=1200: Time=7.899294
La rularea a mai multor teste la final, cel mai mic a fost N=1200: Time=8.419294.

opt_f 
Cel mai mic timp obtinut pentru N=1200: Time=3.365416


opt_f_extra 
Implementarea obtine cu cel putin 5% mai putin decat opt_f.
Cel mai mic timp obtinut pentru N=1200: Time=2.925332.

Am utilizat flag-ul -funsafe-math-optimizations ce permite flagurile: -fno-signed-zeros, -fno-trapping-math, -fassociative-math and -freciprocal-math.
Am ales sa tin cont de verificarea rezultatelor obtinute prin ./compare. Deoarece nu exista 
date cu un numar mai mare de 1200 (1400 pentru reprezentarea graficului) si datele sunt de tip double, am ales sa pun flag-uri de optimizare
pentru rezultatele obtinute- operatiile matematice dintre elementele matricelor.

-fno-signed-zeros - acest flag implica faptul ca semnul lui 0 nu este semnificativ in rezultatele obtinute. 
                    Se obtine o simplificare in operatiile matematice 
                        si nu se mai incearca simplificarea inutila a unor operatii.

-fno-trapping-math -  flag ce asigura ca nu se vor face operatii ce vor rezulta in eroare, precum impartirea la zero, underflow, overflow.
                        Operatiile matematice executate in cod sunt inmultirea si adunarea. Se evita destul de mult lucrul cu elementele 0.
    
-fassociative-math - deoarece operatiile pe care le fac sunt doar de inmultire sau adunare si nu rezulta in nimic complex/ sunt facute in cate o etapa fiecare,
                    , acest flag permite reasociera operatiilor si in felul asta, o opimizare la nivel de date.

-freciprocal-math - poate fi util in unele operatii de inmultire, ajuta la optimizarea calculelor de tipul x/y. Devine o optimizare pentru 
                    datele folosite (elementele matricelor).

    

Graficele obtinute in urma rularii pe cel putin 5 teste:
Am ales sa fac un grafic care sa cuprinda toate cele 5 implementari si rezultatele lor in urma a 5 teste.
Am luat ca referinta pentru N, 400, 800, 1000, 1200, 1400.

Precum se poate observa in grafic, timpul tinde sa creasca exponential, acest lucru cel mai usor de observat la varianta neoptimizata.
Cea mai buna implementare se observa ca poate fi facuta in blas, o diferenta enorma fata de varianta neoptimizata, unde cresterea pare sa 
fie mai mult liniara si nu intr-un ritm foarte rapid. 
Precum descrierea acestor functii o sugereaza, optimizarile lor provin din instructiuni SIMD sau vectori registrii.

Varianta opt_f si opt_f_extra nu par sa faca o mare diferenta pentru N <1000 insa aceasta se observa dupa 1000, de unde cele doua linii
incep sa se indeparteze mult, respectiv exista o optimizare considerabila. 
Pentru  N>1000 se inregistreaza un speedup foarte bun pentru opt_f_extra fata de opt_f. 
Discutand despre optimizarea la nivel de calcule, se observa importanta folosirii unor flag-uri aditionale corespunzatoare nevoilor problemei, 
in cazul implementarilor - operatiile dintre elementele matricelor.

In privinta variantei opt_m, se observa o imbunatatire buna fata de varianta neopt. 
Cresterea este inca exponentiala dar pornind de la un timp mult mai mic fata de varianta neoptimizata. 
Motivul pentru care se poate observa aceasta imbunatatire este diferenta pe care o poate face 
declararea variabilelor ca registrii si folosirea pointerilor, deoarece indiferent de asezarea vectorilor in memorie, 
accesarea elementelor lor este "scumpa" din punct de vedere al performantei. 
Precum am observat si la laboratoare, renuntarea la accesele vectoriale prin derefentiere utilizand pointeri, 
aduce un speedup foarte bun.